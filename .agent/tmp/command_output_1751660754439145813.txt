The "poetry.dev-dependencies" section is deprecated and will be removed in a future version. Use "poetry.group.dev.dependencies" instead.
============================= test session starts ==============================
platform linux -- Python 3.12.1, pytest-8.4.1, pluggy-1.6.0 -- /home/thomas/Projects/label-maker/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/thomas/Projects/llm/plugins/Utilities/llm-jina
configfile: pyproject.toml
plugins: httpx-0.35.0, asyncio-0.25.3, recording-0.13.2, inline-snapshot-0.22.0, env-1.1.5, anyio-4.9.0, requests-mock-1.12.1, mock-3.14.1
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None
collecting ... collected 28 items

tests/unit/test_classifier.py::test_classify_text_auto_model PASSED      [  3%]
tests/unit/test_classifier.py::test_classify_image_auto_model PASSED     [  7%]
tests/unit/test_classifier.py::test_classify_manual_model FAILED         [ 10%]
tests/unit/test_classifier.py::test_classify_invalid_input PASSED        [ 14%]
tests/unit/test_client.py::test_client_init_with_env_var PASSED          [ 17%]
tests/unit/test_client.py::test_client_init_with_direct_key PASSED       [ 21%]
tests/unit/test_client.py::test_client_init_no_key_raises_error PASSED   [ 25%]
tests/unit/test_client.py::test_client_post_request FAILED               [ 28%]
tests/unit/test_commands.py::test_cli_read_command PASSED                [ 32%]
tests/unit/test_commands.py::test_cli_search_command FAILED              [ 35%]
tests/unit/test_commands.py::test_cli_rerank_command FAILED              [ 39%]
tests/unit/test_commands.py::test_cli_segment_command PASSED             [ 42%]
tests/unit/test_commands.py::test_cli_deepsearch_command FAILED          [ 46%]
tests/unit/test_deepsearch.py::test_deepsearch_basic PASSED              [ 50%]
tests/unit/test_deepsearch.py::test_deepsearch_with_history FAILED       [ 53%]
tests/unit/test_embeddings.py::test_jina_embeddings_init PASSED          [ 57%]
tests/unit/test_embeddings.py::test_jina_embeddings_client_property PASSED [ 60%]
tests/unit/test_embeddings.py::test_embed_batch_success FAILED           [ 64%]
tests/unit/test_embeddings.py::test_embed_batch_invalid_response FAILED  [ 67%]
tests/unit/test_reader.py::test_read_basic PASSED                        [ 71%]
tests/unit/test_reader.py::test_read_with_all_headers PASSED             [ 75%]
tests/unit/test_rerank.py::test_rerank_basic PASSED                      [ 78%]
tests/unit/test_rerank.py::test_rerank_with_options PASSED               [ 82%]
tests/unit/test_search.py::test_search_basic PASSED                      [ 85%]
tests/unit/test_search.py::test_search_with_all_options PASSED           [ 89%]
tests/unit/test_segmenter.py::test_segment_basic PASSED                  [ 92%]
tests/unit/test_segmenter.py::test_segment_with_options PASSED           [ 96%]
tests/unit/test_segmenter.py::test_segment_with_tail PASSED              [100%]

=================================== FAILURES ===================================
__________________________ test_classify_manual_model __________________________

self = <MagicMock name='JinaClient().post' id='140317370775840'>
args = ('https://api.jina.ai/v1/classify',)
kwargs = {'data': {'input': [{'image': 'text'}], 'labels': ['label'], 'model': 'jina-clip-v2'}}
expected = call('https://api.jina.ai/v1/classify', data={'model': 'jina-clip-v2', 'input': [{'image': 'text'}], 'labels': ['label']})
actual = call('https://api.jina.ai/v1/classify', data={'model': 'jina-clip-v2', 'input': ['text'], 'labels': ['label']})
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f9dfb3805e0>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: post('https://api.jina.ai/v1/classify', data={'model': 'jina-clip-v2', 'input': [{'image': 'text'}], 'labels': ['label']})
E             Actual: post('https://api.jina.ai/v1/classify', data={'model': 'jina-clip-v2', 'input': ['text'], 'labels': ['label']})

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:944: AssertionError

During handling of the above exception, another exception occurred:

self = <MagicMock name='JinaClient().post' id='140317370775840'>
args = ('https://api.jina.ai/v1/classify',)
kwargs = {'data': {'input': [{'image': 'text'}], 'labels': ['label'], 'model': 'jina-clip-v2'}}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: expected call not found.
E       Expected: post('https://api.jina.ai/v1/classify', data={'model': 'jina-clip-v2', 'input': [{'image': 'text'}], 'labels': ['label']})
E         Actual: post('https://api.jina.ai/v1/classify', data={'model': 'jina-clip-v2', 'input': ['text'], 'labels': ['label']})
E       
E       pytest introspection follows:
E       
E       Kwargs:
E       assert {'data': {'in...ina-clip-v2'}} == {'data': {'in...ina-clip-v2'}}
E         
E         Differing items:
E         {'data': {'input': ['text'], 'labels': ['label'], 'model': 'jina-clip-v2'}} != {'data': {'input': [{'image': 'text'}], 'labels': ['label'], 'model': 'jina-clip-v2'}}
E         
E         Full diff:
E           {
E               'data': {...
E         
E         ...Full output truncated (14 lines hidden), use '-vv' to show

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:956: AssertionError

During handling of the above exception, another exception occurred:

MockJinaClient = <MagicMock name='JinaClient' id='140316545671792'>
mock_env_api_key = 'test_api_key_123'

    @patch("llm_jina.classifier.JinaClient")
    def test_classify_manual_model(MockJinaClient, mock_env_api_key):
        """Test classification with manually specified model."""
        mock_client_instance = MockJinaClient.return_value
        mock_client_instance.post.return_value = {"data": "success"}
    
        inputs = ["text"]
        labels = ["label"]
        classify(inputs=inputs, labels=labels, model="jina-clip-v2")
    
>       mock_client_instance.post.assert_called_once_with(
            "https://api.jina.ai/v1/classify",
            data={
                "model": "jina-clip-v2",
                "input": [{"image": "text"}],  # Formatted for clip model
                "labels": labels,
            }
        )
E       AssertionError: expected call not found.
E       Expected: post('https://api.jina.ai/v1/classify', data={'model': 'jina-clip-v2', 'input': [{'image': 'text'}], 'labels': ['label']})
E         Actual: post('https://api.jina.ai/v1/classify', data={'model': 'jina-clip-v2', 'input': ['text'], 'labels': ['label']})
E       
E       pytest introspection follows:
E       
E       Kwargs:
E       assert {'data': {'in...ina-clip-v2'}} == {'data': {'in...ina-clip-v2'}}
E         
E         Differing items:
E         {'data': {'input': ['text'], 'labels': ['label'], 'model': 'jina-clip-v2'}} != {'data': {'input': [{'image': 'text'}], 'labels': ['label'], 'model': 'jina-clip-v2'}}
E         
E         Full diff:
E           {
E               'data': {...
E         
E         ...Full output truncated (14 lines hidden), use '-vv' to show

tests/unit/test_classifier.py:61: AssertionError
___________________________ test_client_post_request ___________________________

self = <MagicMock name='post' id='140316501824080'>
args = ('https://test.jina.ai/v1/test',)
kwargs = {'headers': {'Accept': 'application/json', 'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json'}, 'json': {'input': 'test'}}
expected = call('https://test.jina.ai/v1/test', json={'input': 'test'}, headers={'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json', 'Accept': 'application/json'})
actual = call('https://test.jina.ai/v1/test', json={'input': 'test'}, headers={'User-Agent': 'python-requests/2.32.4', 'Accept-...ion/json', 'Connection': 'keep-alive', 'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json'})
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f9dfb3862a0>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: post('https://test.jina.ai/v1/test', json={'input': 'test'}, headers={'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json', 'Accept': 'application/json'})
E             Actual: post('https://test.jina.ai/v1/test', json={'input': 'test'}, headers={'User-Agent': 'python-requests/2.32.4', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json', 'Connection': 'keep-alive', 'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json'})

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:944: AssertionError

During handling of the above exception, another exception occurred:

self = <MagicMock name='post' id='140316501824080'>
args = ('https://test.jina.ai/v1/test',)
kwargs = {'headers': {'Accept': 'application/json', 'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json'}, 'json': {'input': 'test'}}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: expected call not found.
E       Expected: post('https://test.jina.ai/v1/test', json={'input': 'test'}, headers={'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json', 'Accept': 'application/json'})
E         Actual: post('https://test.jina.ai/v1/test', json={'input': 'test'}, headers={'User-Agent': 'python-requests/2.32.4', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json', 'Connection': 'keep-alive', 'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json'})
E       
E       pytest introspection follows:
E       
E       Kwargs:
E       assert {'headers': {...put': 'test'}} == {'headers': {...put': 'test'}}
E         
E         Omitting 1 identical items, use -vv to show
E         Differing items:
E         {'headers': {'User-Agent': 'python-requests/2.32.4', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json', 'Connection': 'keep-alive', 'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json'}} != {'headers': {'Accept': 'application/json', 'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json'}}
E         
E         Full diff:
E           {...
E         
E         ...Full output truncated (10 lines hidden), use '-vv' to show

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:956: AssertionError

During handling of the above exception, another exception occurred:

mock_env_api_key = 'test_api_key_123'
mock_response = <MagicMock id='140316500883072'>

    def test_client_post_request(mock_env_api_key, mock_response):
        """Test the POST request method of the client."""
        client = JinaClient()
    
        with patch("requests.Session.post", return_value=mock_response) as mock_post:
            test_url = "https://test.jina.ai/v1/test"
            test_data = {"input": "test"}
            response_data = client.post(test_url, test_data)
    
>           mock_post.assert_called_once_with(
                test_url,
                json=test_data,
                headers={
                    "Authorization": f"Bearer {mock_env_api_key}",
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                }
            )
E           AssertionError: expected call not found.
E           Expected: post('https://test.jina.ai/v1/test', json={'input': 'test'}, headers={'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json', 'Accept': 'application/json'})
E             Actual: post('https://test.jina.ai/v1/test', json={'input': 'test'}, headers={'User-Agent': 'python-requests/2.32.4', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json', 'Connection': 'keep-alive', 'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json'})
E           
E           pytest introspection follows:
E           
E           Kwargs:
E           assert {'headers': {...put': 'test'}} == {'headers': {...put': 'test'}}
E             
E             Omitting 1 identical items, use -vv to show
E             Differing items:
E             {'headers': {'User-Agent': 'python-requests/2.32.4', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json', 'Connection': 'keep-alive', 'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json'}} != {'headers': {'Accept': 'application/json', 'Authorization': 'Bearer test_api_key_123', 'Content-Type': 'application/json'}}
E             
E             Full diff:
E               {...
E             
E             ...Full output truncated (10 lines hidden), use '-vv' to show

tests/unit/test_client.py:38: AssertionError
___________________________ test_cli_search_command ____________________________

args = ()
keywargs = {'runner': <click.testing.CliRunner object at 0x7f9dfb3ec200>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1384: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/thomas/miniconda3/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1366: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/thomas/miniconda3/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f9dfdd6e360>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <Command search> does not have the attribute 'search'

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1428: AttributeError
___________________________ test_cli_rerank_command ____________________________

args = ()
keywargs = {'runner': <click.testing.CliRunner object at 0x7f9dfb3f7860>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1384: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/thomas/miniconda3/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1366: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/thomas/miniconda3/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f9dfdd6d040>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <Command rerank> does not have the attribute 'rerank'

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1428: AttributeError
_________________________ test_cli_deepsearch_command __________________________

args = ()
keywargs = {'runner': <click.testing.CliRunner object at 0x7f9dfb3ed970>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1384: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/thomas/miniconda3/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1366: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/thomas/miniconda3/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f9dfdd6d280>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <Command deepsearch> does not have the attribute 'deepsearch'

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1428: AttributeError
_________________________ test_deepsearch_with_history _________________________

self = <MagicMock name='JinaClient().post' id='140316412814368'>
args = ('https://deepsearch.jina.ai/v1/chat/completions',)
kwargs = {'data': {'max_returned_urls': 5, 'messages': [{'content': 'What is the capital of France?', 'role': 'user'}, {'conten...r'}, {'content': 'What about Rome?', 'role': 'user'}], 'model': 'jina-deepsearch-v1', 'reasoning_effort': 'high', ...}}
expected = call('https://deepsearch.jina.ai/v1/chat/completions', data={'model': 'jina-deepsearch-v1', 'messages': [{'role': 'use...{'role': 'user', 'content': 'What about Rome?'}], 'reasoning_effort': 'high', 'max_returned_urls': 5, 'stream': False})
actual = call('https://deepsearch.jina.ai/v1/chat/completions', data={'model': 'jina-deepsearch-v1', 'messages': [{'role': 'use...{'role': 'user', 'content': 'What about Rome?'}], 'reasoning_effort': 'high', 'max_returned_urls': 5, 'stream': False})
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f9dfb3dc2c0>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: post('https://deepsearch.jina.ai/v1/chat/completions', data={'model': 'jina-deepsearch-v1', 'messages': [{'role': 'user', 'content': 'What is the capital of France?'}, {'role': 'assistant', 'content': 'Paris'}, {'role': 'user', 'content': 'What about Rome?'}, {'role': 'user', 'content': 'What about Rome?'}], 'reasoning_effort': 'high', 'max_returned_urls': 5, 'stream': False})
E             Actual: post('https://deepsearch.jina.ai/v1/chat/completions', data={'model': 'jina-deepsearch-v1', 'messages': [{'role': 'user', 'content': 'What is the capital of France?'}, {'role': 'assistant', 'content': 'Paris'}, {'role': 'user', 'content': 'What about Rome?'}], 'reasoning_effort': 'high', 'max_returned_urls': 5, 'stream': False})

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:944: AssertionError

During handling of the above exception, another exception occurred:

self = <MagicMock name='JinaClient().post' id='140316412814368'>
args = ('https://deepsearch.jina.ai/v1/chat/completions',)
kwargs = {'data': {'max_returned_urls': 5, 'messages': [{'content': 'What is the capital of France?', 'role': 'user'}, {'conten...r'}, {'content': 'What about Rome?', 'role': 'user'}], 'model': 'jina-deepsearch-v1', 'reasoning_effort': 'high', ...}}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: expected call not found.
E       Expected: post('https://deepsearch.jina.ai/v1/chat/completions', data={'model': 'jina-deepsearch-v1', 'messages': [{'role': 'user', 'content': 'What is the capital of France?'}, {'role': 'assistant', 'content': 'Paris'}, {'role': 'user', 'content': 'What about Rome?'}, {'role': 'user', 'content': 'What about Rome?'}], 'reasoning_effort': 'high', 'max_returned_urls': 5, 'stream': False})
E         Actual: post('https://deepsearch.jina.ai/v1/chat/completions', data={'model': 'jina-deepsearch-v1', 'messages': [{'role': 'user', 'content': 'What is the capital of France?'}, {'role': 'assistant', 'content': 'Paris'}, {'role': 'user', 'content': 'What about Rome?'}], 'reasoning_effort': 'high', 'max_returned_urls': 5, 'stream': False})
E       
E       pytest introspection follows:
E       
E       Kwargs:
E       assert {'data': {'ma... 'high', ...}} == {'data': {'ma... 'high', ...}}
E         
E         Differing items:
E         {'data': {'max_returned_urls': 5, 'messages': [{'content': 'What is the capital of France?', 'role': 'user'}, {'conten...t'}, {'content': 'What about Rome?', 'role': 'user'}], 'model': 'jina-deepsearch-v1', 'reasoning_effort': 'high', ...}} != {'data': {'max_returned_urls': 5, 'messages': [{'content': 'What is the capital of France?', 'role': 'user'}, {'conten...r'}, {'content': 'What about Rome?', 'role': 'user'}], 'model': 'jina-deepsearch-v1', 'reasoning_effort': 'high', ...}}
E         
E         Full diff:
E           {
E               'data': {...
E         
E         ...Full output truncated (24 lines hidden), use '-vv' to show

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:956: AssertionError

During handling of the above exception, another exception occurred:

MockJinaClient = <MagicMock name='JinaClient' id='140316412806832'>
mock_env_api_key = 'test_api_key_123'

    @patch("llm_jina.deepsearch.JinaClient")
    def test_deepsearch_with_history(MockJinaClient, mock_env_api_key):
        """Test deepsearch function with conversation history."""
        mock_client_instance = MockJinaClient.return_value
        mock_client_instance.post.return_value = {"choices": [{"message": {"content": "Test response"}}]}
    
        query = "What about Rome?"
        history = [
            {"role": "user", "content": "What is the capital of France?"},
            {"role": "assistant", "content": "Paris"}
        ]
    
        deepsearch(
            query=query,
            history=history,
            reasoning_effort="high",
            max_returned_urls=5,
            api_key="specific_key"
        )
    
        MockJinaClient.assert_called_once_with("specific_key")
    
        expected_messages = history + [{"role": "user", "content": query}]
>       mock_client_instance.post.assert_called_once_with(
            "https://deepsearch.jina.ai/v1/chat/completions",
            data={
                "model": "jina-deepsearch-v1",
                "messages": expected_messages,
                "reasoning_effort": "high",
                "max_returned_urls": 5,
                "stream": False,
            }
        )
E       AssertionError: expected call not found.
E       Expected: post('https://deepsearch.jina.ai/v1/chat/completions', data={'model': 'jina-deepsearch-v1', 'messages': [{'role': 'user', 'content': 'What is the capital of France?'}, {'role': 'assistant', 'content': 'Paris'}, {'role': 'user', 'content': 'What about Rome?'}, {'role': 'user', 'content': 'What about Rome?'}], 'reasoning_effort': 'high', 'max_returned_urls': 5, 'stream': False})
E         Actual: post('https://deepsearch.jina.ai/v1/chat/completions', data={'model': 'jina-deepsearch-v1', 'messages': [{'role': 'user', 'content': 'What is the capital of France?'}, {'role': 'assistant', 'content': 'Paris'}, {'role': 'user', 'content': 'What about Rome?'}], 'reasoning_effort': 'high', 'max_returned_urls': 5, 'stream': False})
E       
E       pytest introspection follows:
E       
E       Kwargs:
E       assert {'data': {'ma... 'high', ...}} == {'data': {'ma... 'high', ...}}
E         
E         Differing items:
E         {'data': {'max_returned_urls': 5, 'messages': [{'content': 'What is the capital of France?', 'role': 'user'}, {'conten...t'}, {'content': 'What about Rome?', 'role': 'user'}], 'model': 'jina-deepsearch-v1', 'reasoning_effort': 'high', ...}} != {'data': {'max_returned_urls': 5, 'messages': [{'content': 'What is the capital of France?', 'role': 'user'}, {'conten...r'}, {'content': 'What about Rome?', 'role': 'user'}], 'model': 'jina-deepsearch-v1', 'reasoning_effort': 'high', ...}}
E         
E         Full diff:
E           {
E               'data': {...
E         
E         ...Full output truncated (24 lines hidden), use '-vv' to show

tests/unit/test_deepsearch.py:55: AssertionError
___________________________ test_embed_batch_success ___________________________

self = <unittest.mock._patch object at 0x7f9dfb320710>

    def __enter__(self):
        """Perform the patch."""
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
            if spec is None and _is_async_obj(original):
                Klass = AsyncMock
            else:
                Klass = MagicMock
            _kwargs = {}
            if new_callable is not None:
                Klass = new_callable
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
    
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: property 'client' of 'JinaEmbeddings' object has no setter

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1564: AttributeError

During handling of the above exception, another exception occurred:

mock_env_api_key = 'test_api_key_123'

    def test_embed_batch_success(mock_env_api_key):
        """Test successful embedding batch operation."""
        model = JinaEmbeddings("jina-embeddings-v3")
    
        mock_response = {
            "data": [
                {"index": 0, "embedding": [0.1, 0.2, 0.3]},
                {"index": 1, "embedding": [0.4, 0.5, 0.6]}
            ]
        }
    
>       with patch.object(model, 'client') as mock_client:

tests/unit/test_embeddings.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1577: in __enter__
    if not self.__exit__(*sys.exc_info()):
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f9dfb320710>
exc_info = (<class 'AttributeError'>, AttributeError("property 'client' of 'JinaEmbeddings' object has no setter"), <traceback object at 0x7f9df354d7c0>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: property 'client' of 'JinaEmbeddings' object has no deleter

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1585: AttributeError
______________________ test_embed_batch_invalid_response _______________________

self = <unittest.mock._patch object at 0x7f9dfb3f5070>

    def __enter__(self):
        """Perform the patch."""
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
            if spec is None and _is_async_obj(original):
                Klass = AsyncMock
            else:
                Klass = MagicMock
            _kwargs = {}
            if new_callable is not None:
                Klass = new_callable
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
    
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: property 'client' of 'JinaEmbeddings' object has no setter

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1564: AttributeError

During handling of the above exception, another exception occurred:

mock_env_api_key = 'test_api_key_123'

    def test_embed_batch_invalid_response(mock_env_api_key):
        """Test handling of invalid response format."""
        model = JinaEmbeddings("jina-embeddings-v3")
    
        mock_response = {"invalid": "response"}
    
>       with patch.object(model, 'client') as mock_client:

tests/unit/test_embeddings.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1577: in __enter__
    if not self.__exit__(*sys.exc_info()):
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f9dfb3f5070>
exc_info = (<class 'AttributeError'>, AttributeError("property 'client' of 'JinaEmbeddings' object has no setter"), <traceback object at 0x7f9df35c2980>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: property 'client' of 'JinaEmbeddings' object has no deleter

/home/thomas/miniconda3/lib/python3.12/unittest/mock.py:1585: AttributeError
=========================== short test summary info ============================
FAILED tests/unit/test_classifier.py::test_classify_manual_model - AssertionE...
FAILED tests/unit/test_client.py::test_client_post_request - AssertionError: ...
FAILED tests/unit/test_commands.py::test_cli_search_command - AttributeError:...
FAILED tests/unit/test_commands.py::test_cli_rerank_command - AttributeError:...
FAILED tests/unit/test_commands.py::test_cli_deepsearch_command - AttributeEr...
FAILED tests/unit/test_deepsearch.py::test_deepsearch_with_history - Assertio...
FAILED tests/unit/test_embeddings.py::test_embed_batch_success - AttributeErr...
FAILED tests/unit/test_embeddings.py::test_embed_batch_invalid_response - Att...
========================= 8 failed, 20 passed in 0.71s =========================
